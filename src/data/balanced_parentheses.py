import jax
import jax.numpy as jnp

class BalancedParenthesesDataset:
    """
    Balanced Parentheses task dataset.

    Given a sequence of tokens (parentheses and lag), the model must predict 1 if the sequence is grammatically correct (well-formed), 
    and -1 otherwise, reported only at the final position in the sequence (rest are zero / ignored in training).

    Args:
        tokens: List of tuples (open_token, close_token) as ints.
        batch_size: number of samples per batch.
        min_seq_length: minimal random sequence length (excluding lag).
        max_seq_length: maximal random sequence length.
        max_recursion_depth: maximal parenthesis depth.
        p_valid: probability a sample is correct. If <1, incorrect samples are generated by corrupting correct ones.
        corruption_lambda: expon. parameter for number of corruptions if p_valid<1.
        lag_time: time steps between end of sequence and reporting position.
        lag_noise: noise std to add during lag.
    """
    def __init__(
        self,
        tokens,
        batch_size: int,
        min_seq_length: int = 4,
        max_seq_length: int = 32,
        max_recursion_depth: int = 10,
        p_valid: float = 0.5,
        corruption_lambda: float = 1.0,
        lag_time: int = 5,
        lag_noise: float = 0.0,
        seed: int = 0,
    ):
        self.tokens = tokens
        self.batch_size = 1  # Fixed to 1 for variable length sequences
        self.min_seq_length = min_seq_length
        self.max_seq_length = max_seq_length
        self.max_recursion_depth = max_recursion_depth
        self.p_valid = p_valid
        self.corruption_lambda = corruption_lambda
        self.lag_time = lag_time
        self.lag_noise = lag_noise
        self.open_tokens = [pair[0] for pair in tokens]
        self.close_tokens = [pair[1] for pair in tokens]
        # Make vocabulary include all unique tokens
        self.vocab = list(sorted(set(self.open_tokens + self.close_tokens)))
        self.pad_token = max(self.vocab) + 1  # For padding if needed
        self.report_token = self.pad_token + 1  # End delimiter/report token (optional)
        self.key = jax.random.PRNGKey(seed)

    def __call__(self):
        return self.make_balanced_paren_batch()

    def make_balanced_paren_batch(self):
        # Split key for this batch
        self.key, batch_key = jax.random.split(self.key)
        
        # Generate single sample (batch_size = 1)
        sample_key = batch_key
        seq_len = None  # Will be determined by generated sequence length
        
        inp, tgt, msk = self._generate_single_sample(sample_key, seq_len)
        
        # Return single sample with batch dimension
        inputs = inp[None, ...]
        targets = tgt[None, ...]
        masks = msk[None, ...]
        
        return inputs, targets, masks
    
    def _generate_single_sample(self, rng, seq_len):
        """Generate a single parentheses sample with lag period."""
        # Split keys for different random operations
        keys = jax.random.split(rng, 4)
        
        # Decide if this sample should be valid
        is_valid = jax.random.uniform(keys[1]) < self.p_valid
        
        # Generate valid parentheses sequence using CFG
        sequence = self._generate_valid_sequence(keys[2])
        
        # Ensure minimum length
        while len(sequence) < self.min_seq_length:
            sequence = self._generate_valid_sequence(keys[2])
        
        # Truncate if too long
        sequence = sequence[:self.max_seq_length]
        
        # Corrupt if needed
        if not is_valid:
            sequence = self._corrupt_sequence(sequence, keys[3])
        
        # Check the actual validity of the sequence
        actual_label = self.check_balanced_parentheses(sequence)
        
        # Build full input with lag period
        total_length = len(sequence) + self.lag_time
        
        # Initialize with pad tokens
        input_seq = jnp.full((total_length,), self.pad_token, dtype=jnp.int32)
        input_seq = input_seq.at[:len(sequence)].set(sequence)
        
        # Create target: only last position has the label
        target_seq = jnp.zeros((total_length,), dtype=jnp.int32)
        target_seq = target_seq.at[-1].set(actual_label)
        
        # Create mask: only last position is used for loss
        mask_seq = jnp.zeros((total_length,), dtype=jnp.int32)
        mask_seq = mask_seq.at[-1].set(1)
        
        return input_seq, target_seq, mask_seq
    
    def _generate_valid_sequence(self, rng):
        """
        Generate a valid balanced parentheses sequence using context-free grammar.
        
        Context-Free Grammar:
        S → ε | O S C S
        Where:
        - S is a balanced sequence (start symbol)
        - ε is empty string
        - O is an opening parenthesis (random choice from open_tokens)
        - C is the matching closing parenthesis for O
        - Recursive structure ensures proper nesting
        """
        def recursive_generate(key, current_depth, max_depth):
            if current_depth >= max_depth or jax.random.uniform(key) < 0.3:  # Base case
                return [], key
            
            # Split key for choosing open token and recursion
            key, open_key, subkey1, subkey2 = jax.random.split(key, 4)
            
            # Choose random open token
            open_idx = jax.random.randint(open_key, shape=(), minval=0, maxval=len(self.open_tokens))
            open_token = self.open_tokens[int(open_idx)]
            close_token = self.close_tokens[open_idx]
            
            # Generate inner sequence S1
            inner_seq1, key = recursive_generate(subkey1, current_depth + 1, max_depth)
            
            # Generate following sequence S2
            following_seq, key = recursive_generate(subkey2, current_depth, max_depth)
            
            # Build O S1 C S2
            sequence = [open_token] + inner_seq1 + [close_token] + following_seq
            return sequence, key
        
        # Generate sequence with random depth
        key, depth_key = jax.random.split(rng)
        max_depth = jax.random.randint(depth_key, shape=(), minval=1, maxval=self.max_recursion_depth + 1)
        
        sequence, _ = recursive_generate(key, 0, int(max_depth))
        
        return jnp.array(sequence, dtype=jnp.int32)
    
    def _corrupt_sequence(self, sequence, rng):
        """Corrupt a valid sequence by random substitutions."""
        key1, self.key2 = jax.random.split(rng)
        
        # Sample number of corruptions from Poisson distribution
        num_corruptions = jax.random.poisson(key1, lam=self.corruption_lambda)
        num_corruptions = jnp.minimum(num_corruptions, len(sequence) // 2 + 1)
        num_corruptions = int(num_corruptions)
        
        if num_corruptions == 0:
            return sequence
        
        # Choose random positions to corrupt
        seq_len = len(sequence)
        if num_corruptions >= seq_len:
            corrupt_positions = jnp.arange(seq_len)
        else:
            corrupt_positions = jax.random.choice(
                self.key2, 
                jnp.arange(seq_len), 
                shape=(num_corruptions,), 
                replace=False
            )
        
        # Corrupt each position
        def corrupt_single(corrupted, i):
            pos = int(corrupt_positions[i])
            original_token = sequence[pos]
            
            # Choose a different token from vocabulary
            valid_choices = [t for t in self.vocab if t != original_token]
            if valid_choices:
                self.key2, subkey = jax.random.split(self.key2)
                new_token = jax.random.choice(subkey, jnp.array(valid_choices, dtype=jnp.int32))
                corrupted = corrupted.at[pos].set(new_token)
            return corrupted
        
        corrupted = sequence
        for i in range(num_corruptions):
            corrupted = corrupt_single(corrupted, i)
        
        return corrupted

    def check_balanced_parentheses(self, sequence):
        """
        Check if a sequence of parentheses is balanced.
        Returns 1 if balanced, -1 if not.
        """
        stack = []
        for token in sequence:
            token = int(token)
            if token in self.open_tokens:
                # Opening parenthesis
                stack.append(token)
            elif token in self.close_tokens:
                # Closing parenthesis
                if not stack:
                    return -1  # No matching open
                open_token = stack[-1]
                # Find the matching close token for this open token
                open_idx = self.open_tokens.index(open_token)
                expected_close = self.close_tokens[open_idx]
                if token != expected_close:
                    return -1  # Mismatched
                stack.pop()
            # Ignore other tokens (like pad tokens)
        
        # Check if all opened parentheses were closed
        return 1 if len(stack) == 0 else -1